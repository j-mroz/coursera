/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef dht_proto_TYPES_H
#define dht_proto_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace proto { namespace dht {

struct ReqType {
  enum type {
    CREATE = 0,
    READ = 1,
    UPDATE = 2,
    DELETE = 3,
    CREATE_RSP = 4,
    READ_RSP = 5,
    DELETE_RSP = 6,
    UPDATE_RSP = 7,
    SYNC_BEGIN = 8,
    SYNC_END = 9
  };
};

extern const std::map<int, const char*> _ReqType_VALUES_TO_NAMES;

struct ReqStatus {
  enum type {
    OK = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _ReqStatus_VALUES_TO_NAMES;

class IpAddr;

class Header;

class Body;

class Message;

typedef struct _IpAddr__isset {
  _IpAddr__isset() : bytes(false) {}
  bool bytes :1;
} _IpAddr__isset;

class IpAddr {
 public:

  IpAddr(const IpAddr&);
  IpAddr& operator=(const IpAddr&);
  IpAddr() : bytes() {
  }

  virtual ~IpAddr() throw();
  std::string bytes;

  _IpAddr__isset __isset;

  void __set_bytes(const std::string& val);

  bool operator == (const IpAddr & rhs) const
  {
    if (!(bytes == rhs.bytes))
      return false;
    return true;
  }
  bool operator != (const IpAddr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IpAddr & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IpAddr &a, IpAddr &b);

inline std::ostream& operator<<(std::ostream& out, const IpAddr& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Header__isset {
  _Header__isset() : protocol(true), version(true), type(false), status(false), seqId(false), transaction(false), srcAddr(false), srcPort(false) {}
  bool protocol :1;
  bool version :1;
  bool type :1;
  bool status :1;
  bool seqId :1;
  bool transaction :1;
  bool srcAddr :1;
  bool srcPort :1;
} _Header__isset;

class Header {
 public:

  Header(const Header&);
  Header& operator=(const Header&);
  Header() : protocol(213), version(1), type((ReqType::type)0), status((ReqStatus::type)0), seqId(0), transaction(0), srcPort(0) {
  }

  virtual ~Header() throw();
  int8_t protocol;
  int8_t version;
  ReqType::type type;
  ReqStatus::type status;
  int32_t seqId;
  int32_t transaction;
  IpAddr srcAddr;
  int16_t srcPort;

  _Header__isset __isset;

  void __set_protocol(const int8_t val);

  void __set_version(const int8_t val);

  void __set_type(const ReqType::type val);

  void __set_status(const ReqStatus::type val);

  void __set_seqId(const int32_t val);

  void __set_transaction(const int32_t val);

  void __set_srcAddr(const IpAddr& val);

  void __set_srcPort(const int16_t val);

  bool operator == (const Header & rhs) const
  {
    if (!(protocol == rhs.protocol))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(seqId == rhs.seqId))
      return false;
    if (!(transaction == rhs.transaction))
      return false;
    if (!(srcAddr == rhs.srcAddr))
      return false;
    if (!(srcPort == rhs.srcPort))
      return false;
    return true;
  }
  bool operator != (const Header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Header & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Header &a, Header &b);

inline std::ostream& operator<<(std::ostream& out, const Header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Body__isset {
  _Body__isset() : key(false), value(false), keyValueMap(false) {}
  bool key :1;
  bool value :1;
  bool keyValueMap :1;
} _Body__isset;

class Body {
 public:

  Body(const Body&);
  Body& operator=(const Body&);
  Body() : key(), value() {
  }

  virtual ~Body() throw();
  std::string key;
  std::string value;
  std::map<std::string, std::string>  keyValueMap;

  _Body__isset __isset;

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  void __set_keyValueMap(const std::map<std::string, std::string> & val);

  bool operator == (const Body & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(keyValueMap == rhs.keyValueMap))
      return false;
    return true;
  }
  bool operator != (const Body &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Body & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Body &a, Body &b);

inline std::ostream& operator<<(std::ostream& out, const Body& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Message__isset {
  _Message__isset() : header(false), body(false) {}
  bool header :1;
  bool body :1;
} _Message__isset;

class Message {
 public:

  Message(const Message&);
  Message& operator=(const Message&);
  Message() {
  }

  virtual ~Message() throw();
  Header header;
  Body body;

  _Message__isset __isset;

  void __set_header(const Header& val);

  void __set_body(const Body& val);

  bool operator == (const Message & rhs) const
  {
    if (!(header == rhs.header))
      return false;
    if (!(body == rhs.body))
      return false;
    return true;
  }
  bool operator != (const Message &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Message & ) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Message &a, Message &b);

inline std::ostream& operator<<(std::ostream& out, const Message& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#include "dht_proto_types.tcc"

#endif
